const {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  PermissionFlagsBits,
  ChannelType,
  StringSelectMenuBuilder,
  MessageFlags,
} = require("discord.js");

const {
  activeGames,
  playerSelections,
  ROLES,
  ROLE_DESCRIPTIONS,
} = require("../utils/mafiaState");

// ====== IDs ======
const ticketCategoryId = "1411375711066788021"; // ŸÉÿßÿ™Ÿäÿ¨Ÿàÿ±Ÿä ÿßŸÑÿ™ŸäŸÉÿ™ÿßÿ™
const ticketLogsId = "1411376005268111512"; // ÿ±ŸàŸÖ ÿßŸÑŸÑŸàÿ¨ÿ≤

module.exports = {
  name: "interactionCreate",
  async execute(interaction, client) {
    // ===== Slash Commands =====
    if (interaction.isChatInputCommand()) {
      const command = client.commands.get(interaction.commandName);
      if (!command) return;
      try {
        await command.execute(interaction, client);
      } catch (error) {
        console.error(error);
        const reply = {
          content: "‚ùå ÿ≠ÿµŸÑ ÿÆÿ∑ÿ£ ŸàÿßŸÜÿ™ ÿ®ÿ™ŸÜŸëŸÅÿ∞ ÿßŸÑÿ£ŸÖÿ±!",
          ephemeral: true,
        };
        if (interaction.replied || interaction.deferred) {
          await interaction.followUp(reply);
        } else {
          await interaction.reply(reply);
        }
      }
      return;
    }

    // ===== Tickets =====
    if (interaction.isButton() && interaction.customId.includes("ticket")) {
      const logChannel = interaction.guild.channels.cache.get(ticketLogsId);
      const member = interaction.user;

      // ---------- Create Ticket ----------
      if (interaction.customId === "create_ticket") {
        const existingChannel = interaction.guild.channels.cache.find(
          (c) =>
            c.name.startsWith(`ticket-${member.username}-`) &&
            c.parentId === ticketCategoryId
        );
        if (existingChannel) {
          const memberPermission = existingChannel.permissionsFor(member);
          if (memberPermission.has(PermissionFlagsBits.SendMessages)) {
            return interaction.reply({
              content: "‚ùå You already have an open ticket.",
              flags: MessageFlags.Ephemeral,
            });
          }
        }
        try {
          const randomNum = Math.floor(Math.random() * 100);
          const channelName = `ticket-${member.username.slice(
            0,
            5
          )}-${randomNum}`;
          const channel = await interaction.guild.channels.create({
            name: channelName,
            type: ChannelType.GuildText,
            parent: ticketCategoryId,
            permissionOverwrites: [
              {
                id: interaction.guild.roles.everyone.id,
                deny: [PermissionFlagsBits.ViewChannel],
              },
              {
                id: member.id,
                allow: [
                  PermissionFlagsBits.ViewChannel,
                  PermissionFlagsBits.SendMessages,
                  PermissionFlagsBits.ReadMessageHistory,
                ],
              },
            ],
          });
          const row = new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId("close_ticket")
              .setLabel("Close Ticket")
              .setStyle(ButtonStyle.Danger)
          );
          const ticketEmbed = new EmbedBuilder()
            .setTitle("üé´ Ticket")
            .setDescription(
              `Hello ${member}, describe your issue and our staff will help you soon.`
            )
            .setColor(0x00ff00)
            .setTimestamp();
          await channel.send({
            content: `<@${member.id}>`,
            embeds: [ticketEmbed],
            components: [row],
          });
          // Log
          if (logChannel) {
            const logEmbed = new EmbedBuilder()
              .setTitle("üì© Ticket Opened")
              .addFields(
                { name: "User", value: `${member}`, inline: true },
                { name: "Channel", value: `<#${channel.id}>`, inline: true },
                {
                  name: "Opened At",
                  value: `<t:${Math.floor(Date.now() / 1000)}>`,
                }
              )
              .setColor(0x00ffff)
              .setTimestamp();
            logChannel.send({ embeds: [logEmbed] });
          }
          return interaction.reply({
            content: `‚úÖ Your ticket has been created: <#${channel.id}>`,
            flags: MessageFlags.Ephemeral,
          });
        } catch (error) {
          console.error("Error creating ticket:", error);
          return interaction.reply({
            content:
              "‚ùå Failed to create ticket. Please check bot permissions or category ID.",
            flags: MessageFlags.Ephemeral,
          });
        }
      }

      // ---------- Close Ticket ----------
      if (interaction.customId === "close_ticket") {
        const channel = interaction.channel;
        if (
          member.id !== channel.name.split("-")[1] &&
          !interaction.member.permissions.has(
            PermissionFlagsBits.ManageChannels
          )
        ) {
          return interaction.reply({
            content: "‚ùå You cannot close this ticket.",
            flags: MessageFlags.Ephemeral,
          });
        }
        const row = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId("reopen_ticket")
            .setLabel("Reopen Ticket")
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId("delete_ticket")
            .setLabel("Delete Ticket")
            .setStyle(ButtonStyle.Danger)
        );
        const embed = new EmbedBuilder()
          .setTitle("üîí Ticket Closed")
          .setDescription(`This ticket has been closed by ${member}.`)
          .setColor(0xffcc00)
          .setTimestamp();
        await channel.permissionOverwrites.set([
          {
            id: interaction.guild.roles.everyone.id,
            deny: [
              PermissionFlagsBits.ViewChannel,
              PermissionFlagsBits.SendMessages,
            ],
          },
          {
            id: member.id,
            deny: [
              PermissionFlagsBits.SendMessages,
              PermissionFlagsBits.AddReactions,
              PermissionFlagsBits.AttachFiles,
              PermissionFlagsBits.EmbedLinks,
              PermissionFlagsBits.UseApplicationCommands,
            ],
          },
        ]);
        await channel.send({ embeds: [embed], components: [row] });
        if (logChannel) {
          const logEmbed = new EmbedBuilder()
            .setTitle("üîí Ticket Closed")
            .addFields(
              { name: "User", value: `${member}`, inline: true },
              { name: "Channel", value: `<#${channel.id}>`, inline: true },
              {
                name: "Closed At",
                value: `<t:${Math.floor(Date.now() / 1000)}>`,
              }
            )
            .setColor(0xffcc00)
            .setTimestamp();
          logChannel.send({ embeds: [logEmbed] });
        }
        return interaction.reply({
          content: "‚úÖ Ticket closed.",
          flags: MessageFlags.Ephemeral,
        });
      }

      // ---------- Reopen Ticket ----------
      if (interaction.customId === "reopen_ticket") {
        const channel = interaction.channel;
        if (
          member.id !== channel.name.split("-")[1] &&
          !interaction.member.permissions.has(
            PermissionFlagsBits.ManageChannels
          )
        ) {
          return interaction.reply({
            content: "‚ùå You cannot reopen this ticket.",
            flags: MessageFlags.Ephemeral,
          });
        }
        const row = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId("close_ticket")
            .setLabel("Close Ticket")
            .setStyle(ButtonStyle.Danger)
        );
        const embed = new EmbedBuilder()
          .setTitle("‚úÖ Ticket Reopened")
          .setDescription(`This ticket has been reopened by ${member}.`)
          .setColor(0x00ff00)
          .setTimestamp();
        await channel.permissionOverwrites.edit(member.id, {
          SendMessages: true,
        });
        await channel.permissionOverwrites.edit(
          interaction.guild.roles.everyone.id,
          {
            SendMessages: false,
          }
        );
        await channel.send({ embeds: [embed], components: [row] });
        if (logChannel) {
          const logEmbed = new EmbedBuilder()
            .setTitle("‚úÖ Ticket Reopened")
            .addFields(
              { name: "User", value: `${member}`, inline: true },
              { name: "Channel", value: `<#${channel.id}>`, inline: true },
              {
                name: "Reopened At",
                value: `<t:${Math.floor(Date.now() / 1000)}>`,
              }
            )
            .setColor(0x00ff00)
            .setTimestamp();
          logChannel.send({ embeds: [logEmbed] });
        }
        return interaction.reply({
          content: "‚úÖ Ticket reopened.",
          flags: MessageFlags.Ephemeral,
        });
      }

      // ---------- Delete Ticket ----------
      if (interaction.customId === "delete_ticket") {
        const channel = interaction.channel;
        if (
          member.id !== channel.name.split("-")[1] &&
          !interaction.member.permissions.has(
            PermissionFlagsBits.ManageChannels
          )
        ) {
          return interaction.reply({
            content: "‚ùå You cannot delete this ticket.",
            flags: MessageFlags.Ephemeral,
          });
        }
        await interaction.reply({
          content: "‚úÖ Deleting ticket... Please wait.",
          flags: MessageFlags.Ephemeral,
        });
        try {
          const messages = await channel.messages.fetch({ limit: 100 });
          const logText = messages
            .map(
              (m) => `[${m.author.tag}]: ${m.content || "[Embed/Attachment]"}`
            )
            .reverse()
            .join("\n");
          if (logChannel && logText.length > 0) {
            const logEmbed = new EmbedBuilder()
              .setTitle("üìú Ticket Transcript")
              .addFields(
                { name: "Channel", value: `<#${channel.id}>`, inline: true },
                { name: "Transcript", value: logText.substring(0, 1024) }
              )
              .setColor(0x0000ff)
              .setTimestamp();
            logChannel.send({ embeds: [logEmbed] });
          }
          await channel.delete();
        } catch (error) {
          console.error("Error deleting ticket:", error);
          await interaction.editReply({
            content:
              "‚ùå Failed to delete ticket. Please try again or contact an admin.",
            flags: MessageFlags.Ephemeral,
          });
        }
      }
      return;
    }

    // ===== Mafia Game =====
    if (interaction.isButton() || interaction.isStringSelectMenu()) {
      let game;
      let channelId;

      // ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ channelId ŸÖŸÜ customId ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÅŸä DM
      if (interaction.customId.startsWith("sheriff_investigate_")) {
        channelId = interaction.customId.split("_")[2];
        game = activeGames.get(channelId);
      } else if (interaction.customId.startsWith("doctor_heal_")) {
        channelId = interaction.customId.split("_")[2];
        game = activeGames.get(channelId);
      } else if (interaction.customId.startsWith("mafia_kill_")) {
        channelId = interaction.customId.split("_")[2];
        game = activeGames.get(channelId);
      } else {
        // ŸÑŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿßŸÑÿπÿßŸÖÿ©
        channelId = interaction.channel.id;
        game = activeGames.get(channelId);
      }

      // ŸÑŸà ÿßŸÑŸÑÿπÿ®ÿ© ŸÖÿ¥ ÿ¥ÿ∫ÿßŸÑÿ©
      if (!game && interaction.customId.includes("mafia")) {
        return interaction.reply({
          content: "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÑÿπÿ®ÿ© ŸÜÿ¥ÿ∑ÿ© ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÇŸÜÿßÿ©!",
          ephemeral: true,
        });
      }

      // --- ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÑŸàÿ®Ÿä ---
      if (interaction.customId === "join_mafia") {
        if (game.players.includes(interaction.user.id)) {
          return interaction.reply({
            content: "ÿ£ŸÜÿ™ ŸÖŸÜÿ∂ŸÖ ÿ®ÿßŸÑŸÅÿπŸÑ!",
            ephemeral: true,
          });
        }
        if (game.players.length >= 15) {
          return interaction.reply({
            content: "ÿßŸÑŸÑÿπÿ®ÿ© ŸÖŸÖÿ™ŸÑÿ¶ÿ© (15/15)!",
            ephemeral: true,
          });
        }
        game.players.push(interaction.user.id);
        const embed = updateGameEmbed(game, client);
        return interaction.update({ embeds: [embed] });
      }

      if (interaction.customId === "leave_mafia") {
        if (!game.players.includes(interaction.user.id)) {
          return interaction.reply({
            content: "ÿ£ŸÜÿ™ ŸÑÿ≥ÿ™ ŸÅŸä ÿßŸÑŸÑÿπÿ®ÿ©!",
            ephemeral: true,
          });
        }
        game.players = game.players.filter((id) => id !== interaction.user.id);
        const embed = updateGameEmbed(game, client);
        return interaction.update({ embeds: [embed] });
      }

      if (interaction.customId === "start_mafia") {
        if (game.players.length < 5) {
          return interaction.reply({
            content: "ŸÖÿ∑ŸÑŸàÿ® 5 ŸÑÿßÿπÿ®ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ!",
            ephemeral: true,
          });
        }

        await interaction.deferUpdate();

        // ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÑÿπÿ®ÿ©
        game.alivePlayers = [...game.players];
        game.roles = new Map();
        game.nightActions = new Map();
        game.votes = new Map();
        game.phase = "night";
        game.round = 1;

        // ÿ™Ÿàÿ≤Ÿäÿπ ÿßŸÑÿ£ÿØŸàÿßÿ±
        const roles = assignRoles(game.players);
        console.log("Start sending roles:", Date.now());
        await Promise.all(
          game.players.map((playerId, index) => {
            game.roles.set(playerId, roles[index]);
            return sendRoleToPlayer(client, playerId, roles[index]);
          })
        );
        console.log("Finished sending roles:", Date.now());

        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿ®ÿπÿØ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ£ÿØŸàÿßÿ±
        await interaction.editReply({
          content: "üéÆ ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ£ÿØŸàÿßÿ± ŸÅŸä ÿßŸÑÿÆÿßÿµ.",
          embeds: [],
          components: [],
        });

        // ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑÿ£ÿ≠Ÿäÿßÿ°
        const channel = interaction.channel;
        await channel.send({
          embeds: [createAlivePlayersEmbed(game, client)],
        });

        setTimeout(() => startNightPhase(game, client), 3000);
      }

      // --- ÿ£ÿØŸàÿßÿ± ÿßŸÑŸÑŸäŸÑ ---
      if (interaction.customId.startsWith("sheriff_investigate_")) {
        await handleSheriff(interaction, client, game);
      }
      if (interaction.customId.startsWith("doctor_heal_")) {
        await handleDoctor(interaction, client, game);
      }
      if (interaction.customId.startsWith("mafia_kill_")) {
        await handleMafia(interaction, client, game);
      }

      // --- ÿßŸÑÿ™ÿµŸàŸäÿ™ ---
      if (interaction.customId === "vote_player") {
        await handleVote(interaction, client, game);
      }
    }
  },
};

// =============== Mafia Functions ===============

function assignRoles(players) {
  const roles = [];
  const mafiaCount = players.length >= 7 ? 2 : 1;
  roles.push(...Array(mafiaCount).fill(ROLES.MAFIA));
  roles.push(ROLES.SHERIFF);
  roles.push(ROLES.DOCTOR);
  while (roles.length < players.length) roles.push(ROLES.CITIZEN);
  return shuffleArray(roles);
}

async function sendRoleToPlayer(client, playerId, role) {
  try {
    const user = await client.users.fetch(playerId);
    await user.send({
      embeds: [
        new EmbedBuilder()
          .setTitle(`üé≠ ÿØŸàÿ±ŸÉ: ${role}`)
          .setDescription(ROLE_DESCRIPTIONS[role])
          .setColor(role === ROLES.MAFIA ? 0xff0000 : 0x00ff00),
      ],
    });
  } catch (error) {
    console.error(`ŸÅÿ¥ŸÑ ŸÅŸä ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÑŸÄ ${playerId}:`, error);
  }
}

function updateGameEmbed(game, client) {
  const names = game.players.map((id, index) => {
    const user = client.users.cache.get(id);
    return `${index + 1}. ${user ? user.username : "ŸÖÿ¨ŸáŸàŸÑ"}`;
  });
  return new EmbedBuilder()
    .setTitle("üéÆ ŸÑÿπÿ®ÿ© Mafia")
    .setDescription(
      `üë• ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ (${game.players.length}/15):\n${
        names.join("\n") || "ŸÑÿß ŸäŸàÿ¨ÿØ ŸÑÿßÿπÿ®ŸäŸÜ"
      }`
    )
    .setColor("Random")
    .setFooter({ text: "Ÿäÿ≠ÿ™ÿßÿ¨ 5 ŸÑÿßÿπÿ®ŸäŸÜ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÑŸÑÿ®ÿØÿ°" });
}

function createAlivePlayersEmbed(game, client) {
  const aliveNames = game.alivePlayers.map((id, index) => {
    const user = client.users.cache.get(id);
    return `${index + 1}. ${user ? user.username : "ŸÖÿ¨ŸáŸàŸÑ"}`;
  });

  return new EmbedBuilder()
    .setTitle(`üåô ÿßŸÑŸÑŸäŸÑÿ© ${game.round}`)
    .setDescription(
      `üë• ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑÿ£ÿ≠Ÿäÿßÿ° (${game.alivePlayers.length}):\n${aliveNames.join(
        "\n"
      )}`
    )
    .setColor("#2C2F33");
}

function shuffleArray(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

async function startNightPhase(game, client) {
  const channel = await client.channels.fetch(game.channelId);
  if (!channel) return;

  game.phase = "night";
  game.nightActions.clear(); // ÿ™ŸÜÿ∏ŸäŸÅ ÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÑŸÑŸäŸÑÿ© ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©

  await channel.send("üåô ÿ®ÿØÿ£ÿ™ ŸÑŸäŸÑÿ© ÿ¨ÿØŸäÿØÿ©! ŸÉŸÑ ÿßŸÑÿ£ÿØŸàÿßÿ± ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ™ÿ≠ÿ±ŸÉ...");

  // ÿ®ÿØÿ° ÿØŸàÿ± ÿßŸÑÿ¥Ÿäÿ±ŸÅ
  await sheriffTurn(game, client, channel);
}

// ===== Sheriff Turn =====
async function sheriffTurn(game, client, channel) {
  const sheriffId = [...game.roles.entries()].find(
    ([id, role]) => role === ROLES.SHERIFF && game.alivePlayers.includes(id)
  )?.[0];

  if (!sheriffId) {
    await channel.send("üïµÔ∏è **ÿßŸÑÿ¥Ÿäÿ±ŸÅ ŸÖŸäÿ™** - Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±Ÿá...");
    return setTimeout(() => doctorTurn(game, client, channel), 2000);
  }

  const sheriff = await client.users.fetch(sheriffId);
  const aliveOthers = game.alivePlayers.filter((id) => id !== sheriffId);

  if (aliveOthers.length === 0) return doctorTurn(game, client, channel);

  const selectMenu = new StringSelectMenuBuilder()
    .setCustomId(`sheriff_investigate_${game.channelId}`)
    .setPlaceholder("ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµ ŸÑŸÑÿ™ÿ≠ŸÇŸäŸÇ")
    .addOptions(
      aliveOthers.map((id) => ({
        label: client.users.cache.get(id)?.username || "Unknown",
        value: id,
      }))
    );

  const row = new ActionRowBuilder().addComponents(selectMenu);

  try {
    await sheriff.send({
      content: "üïµÔ∏è **ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµ ŸÑŸÑÿ™ÿ≠ŸÇŸäŸÇ ŸÖÿπŸá:** (ŸÑÿØŸäŸÉ 60 ÿ´ÿßŸÜŸäÿ©)",
      components: [row],
    });
    await channel.send("üïµÔ∏è **ÿØŸàÿ± ÿßŸÑÿ¥Ÿäÿ±ŸÅ** ÿ¨ÿßÿ±Ÿä...");
  } catch (error) {
    await channel.send("üïµÔ∏è **ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ¥Ÿäÿ±ŸÅ** - Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±Ÿá...");
    setTimeout(() => doctorTurn(game, client, channel), 2000);
  }

  // ÿ™ÿßŸäŸÖÿ± ŸÑŸÑÿ¥Ÿäÿ±ŸÅ
  setTimeout(() => {
    if (!game.nightActions.has("sheriff_investigate")) {
      doctorTurn(game, client, channel);
    }
  }, 60000); // ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©
}

// ===== Doctor Turn =====
async function doctorTurn(game, client, channel) {
  const doctorId = [...game.roles.entries()].find(
    ([id, role]) => role === ROLES.DOCTOR && game.alivePlayers.includes(id)
  )?.[0];

  if (!doctorId) {
    await channel.send("‚öïÔ∏è **ÿßŸÑÿ∑ÿ®Ÿäÿ® ŸÖŸäÿ™** - Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±Ÿá...");
    return setTimeout(() => mafiaTurn(game, client, channel), 2000);
  }

  const doctor = await client.users.fetch(doctorId);

  const selectMenu = new StringSelectMenuBuilder()
    .setCustomId(`doctor_heal_${game.channelId}`)
    .setPlaceholder("ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµ ŸÑÿ™ÿ≠ŸÖŸäŸá")
    .addOptions(
      game.alivePlayers.map((id) => ({
        label: client.users.cache.get(id)?.username || "Unknown",
        value: id,
      }))
    );

  const row = new ActionRowBuilder().addComponents(selectMenu);

  try {
    await doctor.send({
      content: "‚öïÔ∏è **ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµ ŸÑÿ™ÿ≠ŸÖŸäŸá:** (ŸÑÿØŸäŸÉ 60 ÿ´ÿßŸÜŸäÿ©)",
      components: [row],
    });
    await channel.send("‚öïÔ∏è **ÿØŸàÿ± ÿßŸÑÿ∑ÿ®Ÿäÿ®** ÿ¨ÿßÿ±Ÿä...");
  } catch (error) {
    await channel.send("‚öïÔ∏è **ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ∑ÿ®Ÿäÿ®** - Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±Ÿá...");
    setTimeout(() => mafiaTurn(game, client, channel), 2000);
  }

  // ÿ™ÿßŸäŸÖÿ± ŸÑŸÑÿ∑ÿ®Ÿäÿ®
  setTimeout(() => {
    if (!game.nightActions.has("doctor_heal")) {
      mafiaTurn(game, client, channel);
    }
  }, 60000);
}

// ===== Mafia Turn =====
async function mafiaTurn(game, client, channel) {
  const mafiaPlayers = [...game.roles.entries()]
    .filter(
      ([id, role]) => role === ROLES.MAFIA && game.alivePlayers.includes(id)
    )
    .map(([id]) => id);

  if (mafiaPlayers.length === 0) {
    await channel.send("üî™ **ŸÉŸÑ ÿßŸÑŸÖÿßŸÅŸäÿß ŸÖÿßÿ™Ÿàÿß** - Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±ŸáŸÖ...");
    return setTimeout(() => startDayPhase(game, client), 2000);
  }

  const mafia = await client.users.fetch(mafiaPlayers[0]);
  const others = game.alivePlayers.filter((id) => !mafiaPlayers.includes(id));

  if (others.length === 0) return startDayPhase(game, client);

  const selectMenu = new StringSelectMenuBuilder()
    .setCustomId(`mafia_kill_${game.channelId}`)
    .setPlaceholder("ÿßÿÆÿ™ÿ± ÿ∂ÿ≠Ÿäÿ©")
    .addOptions(
      others.map((id) => ({
        label: client.users.cache.get(id)?.username || "Unknown",
        value: id,
      }))
    );

  const row = new ActionRowBuilder().addComponents(selectMenu);

  try {
    await mafia.send({
      content: "üî™ **ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµ ŸÑÿ™ŸÇÿ™ŸÑŸá:** (ŸÑÿØŸäŸÉ 60 ÿ´ÿßŸÜŸäÿ©)",
      components: [row],
    });
    await channel.send("üî™ **ÿØŸàÿ± ÿßŸÑŸÖÿßŸÅŸäÿß** ÿ¨ÿßÿ±Ÿä...");
  } catch (error) {
    await channel.send("üî™ **ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑŸÖÿßŸÅŸäÿß** - Ÿäÿ™ŸÖ ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±ŸáŸÖ...");
    setTimeout(() => startDayPhase(game, client), 2000);
  }

  // ÿ™ÿßŸäŸÖÿ± ŸÑŸÑŸÖÿßŸÅŸäÿß
  setTimeout(() => {
    if (!game.nightActions.has("mafia_kill")) {
      startDayPhase(game, client);
    }
  }, 60000);
}

// ===== Day Phase =====
async function startDayPhase(game, client) {
  const channel = await client.channels.fetch(game.channelId);
  if (!channel) return;

  game.phase = "day";

  const killed = game.nightActions.get("mafia_kill");
  const healed = game.nightActions.get("doctor_heal");

  if (killed && killed !== healed) {
    game.alivePlayers = game.alivePlayers.filter((id) => id !== killed);
    game.deadPlayers.push(killed);
    const killedUser = client.users.cache.get(killed);
    const killedRole = game.roles.get(killed);
    await channel.send(
      `üíÄ **${
        killedUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"
      }** ŸÖÿßÿ™ ÿßŸÑÿ®ÿßÿ±ÿ≠ÿ©! ŸÉÿßŸÜ **${killedRole}**`
    );
  } else if (killed && killed === healed) {
    await channel.send(`‚úÖ ÿ™ŸÖ ÿ•ŸÜŸÇÿßÿ∞ ÿ¥ÿÆÿµ ÿßŸÑÿ®ÿßÿ±ÿ≠ÿ©!`);
  } else {
    await channel.send("‚úÖ ŸÖÿ≠ÿØÿ¥ ŸÖÿßÿ™ ÿßŸÑÿ®ÿßÿ±ÿ≠ÿ©!");
  }

  // ŸÅÿ≠ÿµ ÿ¥ÿ±Ÿàÿ∑ ÿßŸÑŸÅŸàÿ≤
  const checkResult = checkWinConditions(game, client);
  if (checkResult) {
    await channel.send({ embeds: [checkResult] });
    activeGames.delete(game.channelId);
    return;
  }

  // ÿπÿ±ÿ∂ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑÿ£ÿ≠Ÿäÿßÿ°
  await channel.send({
    embeds: [createAlivePlayersEmbed(game, client)],
  });

  await startVoting(game, client, channel);
}

// ===== Voting =====
async function startVoting(game, client, channel) {
  game.phase = "voting";
  game.votes.clear();

  const selectMenu = new StringSelectMenuBuilder()
    .setCustomId("vote_player")
    .setPlaceholder("ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµ ŸÑŸÑÿ™ÿµŸàŸäÿ™ ÿ∂ÿØŸá")
    .addOptions(
      game.alivePlayers.map((id) => ({
        label: client.users.cache.get(id)?.username || "Unknown",
        value: id,
      }))
    );

  const row = new ActionRowBuilder().addComponents(selectMenu);

  await channel.send({
    content: "üó≥Ô∏è **ŸàŸÇÿ™ ÿßŸÑÿ™ÿµŸàŸäÿ™!** ŸÑÿØŸäŸÉŸÖ ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©",
    components: [row],
  });

  // ÿ™ÿßŸäŸÖÿ± ŸÑŸÑÿ™ÿµŸàŸäÿ™
  setTimeout(() => {
    processVotes(game, client, channel);
  }, 60000); // ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©
}

// ===== ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ™ÿµŸàŸäÿ™ =====
async function processVotes(game, client, channel) {
  const voteCounts = new Map();
  let voteResults = "üìä **ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ™ÿµŸàŸäÿ™:**\n";

  // ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ£ÿµŸàÿßÿ™
  for (const [voter, target] of game.votes) {
    const count = voteCounts.get(target) || 0;
    voteCounts.set(target, count + 1);
  }

  // ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
  for (const [target, count] of voteCounts) {
    const user = client.users.cache.get(target);
    voteResults += `‚Ä¢ **${user?.username || "ŸÖÿ¨ŸáŸàŸÑ"}**: ${count} ÿµŸàÿ™\n`;
  }

  if (voteCounts.size === 0) {
    await channel.send(voteResults + "\n‚ùå ŸÑŸÖ ŸäÿµŸàÿ™ ÿ£ÿ≠ÿØ! ŸÑÿß Ÿäÿ™ŸÖ ÿ•ÿπÿØÿßŸÖ ÿ£ÿ≠ÿØ.");
    game.round++;
    setTimeout(() => startNightPhase(game, client), 5000);
    return;
  }

  // ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ£ÿπŸÑŸâ ÿπÿØÿØ ÿ£ÿµŸàÿßÿ™
  const maxVotes = Math.max(...voteCounts.values());
  const candidates = [...voteCounts.entries()].filter(
    ([, votes]) => votes === maxVotes
  );

  if (candidates.length > 1) {
    await channel.send(
      voteResults + "\n‚öñÔ∏è ÿ™ÿπÿßÿØŸÑ ŸÅŸä ÿßŸÑÿ™ÿµŸàŸäÿ™! ŸÑÿß Ÿäÿ™ŸÖ ÿ•ÿπÿØÿßŸÖ ÿ£ÿ≠ÿØ."
    );
  } else {
    const [executed] = candidates[0];
    const executedUser = client.users.cache.get(executed);
    const executedRole = game.roles.get(executed);

    game.alivePlayers = game.alivePlayers.filter((id) => id !== executed);
    game.deadPlayers.push(executed);

    await channel.send(
      voteResults +
        `\n‚ö∞Ô∏è **${
          executedUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"
        }** ÿ™ŸÖ ÿ•ÿπÿØÿßŸÖŸá! ŸÉÿßŸÜ **${executedRole}**`
    );
  }

  // ŸÅÿ≠ÿµ ÿ¥ÿ±Ÿàÿ∑ ÿßŸÑŸÅŸàÿ≤
  const checkResult = checkWinConditions(game, client);
  if (checkResult) {
    await channel.send({ embeds: [checkResult] });
    activeGames.delete(game.channelId);
    return;
  }

  // ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ŸÑŸÑŸÑŸäŸÑÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©
  game.round++;
  setTimeout(() => startNightPhase(game, client), 5000);
}

// ===== ŸÅÿ≠ÿµ ÿ¥ÿ±Ÿàÿ∑ ÿßŸÑŸÅŸàÿ≤ =====
function checkWinConditions(game, client) {
  const aliveMafia = game.alivePlayers.filter(
    (id) => game.roles.get(id) === ROLES.MAFIA
  );
  const aliveCitizens = game.alivePlayers.filter(
    (id) => game.roles.get(id) !== ROLES.MAFIA
  );

  if (aliveMafia.length === 0) {
    return new EmbedBuilder()
      .setTitle("üèÜ ŸÅÿßÿ≤ ÿßŸÑŸÖŸàÿßÿ∑ŸÜŸàŸÜ!")
      .setDescription("ÿ™ŸÖ ÿßŸÑŸÇÿ∂ÿßÿ° ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿ£ÿπÿ∂ÿßÿ° ÿßŸÑŸÖÿßŸÅŸäÿß!")
      .setColor("#00FF00")
      .addFields({
        name: "üé≠ ÿßŸÑÿ£ÿØŸàÿßÿ±",
        value: game.players
          .map((id) => {
            const user = client.users.cache.get(id);
            const role = game.roles.get(id);
            const status = game.alivePlayers.includes(id) ? "‚úÖ" : "üíÄ";
            return `${status} **${user?.username || "ŸÖÿ¨ŸáŸàŸÑ"}** - ${role}`;
          })
          .join("\n"),
      });
  }

  if (aliveMafia.length >= aliveCitizens.length) {
    return new EmbedBuilder()
      .setTitle("üèÜ ŸÅÿßÿ≤ÿ™ ÿßŸÑŸÖÿßŸÅŸäÿß!")
      .setDescription("ÿßŸÑŸÖÿßŸÅŸäÿß ÿ™ÿ≥ÿßŸàŸä ÿ£Ÿà ÿ™ŸÅŸàŸÇ ÿπÿØÿØ ÿßŸÑŸÖŸàÿßÿ∑ŸÜŸäŸÜ!")
      .setColor("#FF0000")
      .addFields({
        name: "üé≠ ÿßŸÑÿ£ÿØŸàÿßÿ±",
        value: game.players
          .map((id) => {
            const user = client.users.cache.get(id);
            const role = game.roles.get(id);
            const status = game.alivePlayers.includes(id) ? "‚úÖ" : "üíÄ";
            return `${status} **${user?.username || "ŸÖÿ¨ŸáŸàŸÑ"}** - ${role}`;
          })
          .join("\n"),
      });
  }

  return null;
}

// ===== Interaction Handlers =====
async function handleSheriff(interaction, client, game) {
  const targetId = interaction.values[0];
  game.nightActions.set("sheriff_investigate", targetId);

  const role = game.roles.get(targetId);
  const targetUser = client.users.cache.get(targetId);

  await interaction.reply({
    content:
      role === ROLES.MAFIA
        ? `üî¥ **${targetUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"}** Ÿáÿ∞ÿß ÿßŸÑÿ¥ÿÆÿµ ŸÖÿßŸÅŸäÿß!`
        : `‚úÖ **${targetUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"}** Ÿáÿ∞ÿß ÿßŸÑÿ¥ÿÆÿµ ÿ®ÿ±Ÿäÿ°!`,
    ephemeral: true,
  });

  const channel = await client.channels.fetch(game.channelId);
  setTimeout(() => doctorTurn(game, client, channel), 2000);
}

async function handleDoctor(interaction, client, game) {
  const targetId = interaction.values[0];
  game.nightActions.set("doctor_heal", targetId);

  const targetUser = client.users.cache.get(targetId);
  await interaction.reply({
    content: `‚úÖ ÿ≠ŸÖŸäÿ™ **${targetUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"}**!`,
    ephemeral: true,
  });

  const channel = await client.channels.fetch(game.channelId);
  setTimeout(() => mafiaTurn(game, client, channel), 2000);
}

async function handleMafia(interaction, client, game) {
  const targetId = interaction.values[0];
  game.nightActions.set("mafia_kill", targetId);

  const targetUser = client.users.cache.get(targetId);
  await interaction.reply({
    content: `üî™ ÿßÿÆÿ™ÿ±ÿ™ **${targetUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"}** ŸÉÿ∂ÿ≠Ÿäÿ©!`,
    ephemeral: true,
  });

  setTimeout(() => startDayPhase(game, client), 2000);
}

async function handleVote(interaction, client, game) {
  const targetId = interaction.values[0];
  const voterId = interaction.user.id;

  if (!game.alivePlayers.includes(voterId)) {
    return interaction.reply({
      content: "üíÄ ÿßŸÑŸÖŸàÿ™Ÿâ ŸÑÿß ŸäÿµŸàÿ™ŸàŸÜ!",
      ephemeral: true,
    });
  }

  game.votes.set(voterId, targetId);
  const targetUser = client.users.cache.get(targetId);

  await interaction.reply({
    content: `üó≥Ô∏è ÿµŸàÿ™ŸÉ ÿßÿ™ÿ≥ÿ¨ŸÑ ÿ∂ÿØ **${targetUser?.username || "ŸÖÿ¨ŸáŸàŸÑ"}**`,
    ephemeral: true,
  });
}
